<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Schedule Overlay</title>
    <style>
        body {
            background-color: transparent !important; /* Essential for transparency in PRISM */
            color: white; /* Choose a color visible on your stream */
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            text-shadow: 1px 1px 2px black; /* Optional: for better readability */
            overflow: hidden; /* Prevent scrollbars if content is too big */
        }
        #schedule-info {
            border: 1px solid rgba(255, 255, 255, 0.5); /* Optional border */
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.3); /* Slightly dark background for text */
            border-radius: 5px;
            font-size: 18px; /* Adjust as needed */
        }
        .event-item {
            margin-bottom: 8px;
        }
        .event-time {
            font-weight: bold;
            color: #a0e0ff; /* Light blue for time */
        }
        .event-description {
            color: #f0f0f0;
        }
        .status {
            font-style: italic;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div id="schedule-info">
        <p class="status">Loading schedule...</p>
    </div>

    <script>
        // IMPORTANT: Replace with the ACTUAL URL where your schedule.json is hosted
        const scheduleJsonUrl = 'https://github.com/erwin74w/StreamWeaver/blob/main/schedule.json';

        const scheduleInfoDiv = document.getElementById('schedule-info');

        function formatTime(date) {
            if (!date || isNaN(date.getTime())) return "Invalid Date";
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        async function fetchAndDisplaySchedule() {
            try {
                const response = await fetch(scheduleJsonUrl + '?t=' + new Date().getTime()); // Cache buster
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const scheduleData = await response.json();

                if (!scheduleData || !scheduleData.events) {
                    scheduleInfoDiv.innerHTML = '<p class="status">No schedule data found.</p>';
                    return;
                }

                const now = new Date();
                let streamStartTime = null;
                if (scheduleData.stream_start_reference_time_utc) {
                    streamStartTime = new Date(scheduleData.stream_start_reference_time_utc);
                }

                let currentEvent = null;
                let nextEvent = null;
                let closestNextTimeDiff = Infinity;

                scheduleData.events.forEach(event => {
                    let eventStartTime;
                    if (event.timing_type === 'absolute_utc' && event.timestamp_utc) {
                        eventStartTime = new Date(event.timestamp_utc);
                    } else if (event.timing_type === 'relative_to_stream_start' && streamStartTime && typeof event.offset_seconds === 'number') {
                        eventStartTime = new Date(streamStartTime.getTime() + event.offset_seconds * 1000);
                    } else {
                        return; // Skip if we can't determine start time
                    }

                    if (isNaN(eventStartTime.getTime())) return; // Skip invalid dates

                    // Check if current
                    if (event.duration_seconds && eventStartTime <= now) {
                        const eventEndTime = new Date(eventStartTime.getTime() + event.duration_seconds * 1000);
                        if (now < eventEndTime) {
                            currentEvent = { ...event, calculatedStartTime: eventStartTime, calculatedEndTime: eventEndTime };
                        }
                    } else if (!event.duration_seconds && eventStartTime <= now) {
                        // If no duration, assume it could be current if it's the latest past event (simplification)
                        // This logic might need refinement based on how you want to define "current" for events without duration
                    }


                    // Check if next
                    if (eventStartTime > now) {
                        const diff = eventStartTime - now;
                        if (diff < closestNextTimeDiff) {
                            closestNextTimeDiff = diff;
                            nextEvent = { ...event, calculatedStartTime: eventStartTime };
                        }
                    }
                });

                let htmlContent = `<h3>${scheduleData.schedule_name || 'Stream Schedule'}</h3>`;

                if (currentEvent) {
                    htmlContent += `
                        <div class="event-item">
                            <span class="event-time">NOW (${formatTime(currentEvent.calculatedStartTime)} - ${formatTime(currentEvent.calculatedEndTime)}):</span>
                            <span class="event-description">${currentEvent.description} (${currentEvent.action} ${currentEvent.source_name})</span>
                        </div>`;
                } else {
                    htmlContent += `<p class="status">No event currently active according to schedule.</p>`;
                }

                if (nextEvent) {
                    htmlContent += `
                        <div class="event-item">
                            <span class="event-time">UP NEXT (${formatTime(nextEvent.calculatedStartTime)}):</span>
                            <span class="event-description">${nextEvent.description} (${nextEvent.action} ${nextEvent.source_name})</span>
                        </div>`;
                } else {
                     htmlContent += `<p class="status">No upcoming events scheduled.</p>`;
                }

                 if (!currentEvent && !nextEvent && scheduleData.events.length > 0) {
                    htmlContent += `<p class="status">All scheduled events might have passed or stream hasn't reached reference start.</p>`;
                }


                scheduleInfoDiv.innerHTML = htmlContent;

            } catch (error) {
                console.error('Error fetching or displaying schedule:', error);
                scheduleInfoDiv.innerHTML = `<p class="status">Error loading schedule: ${error.message}</p>`;
            }
        }

        // Fetch and display initially, then refresh every 30 seconds
        fetchAndDisplaySchedule();
        setInterval(fetchAndDisplaySchedule, 30000); // 30 seconds
    </script>
</body>
</html>
